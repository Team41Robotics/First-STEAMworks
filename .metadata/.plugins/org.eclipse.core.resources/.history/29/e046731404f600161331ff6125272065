#include "LidarLite.h"


	LidarLite::LidarLite(I2C::Port port, int deviceaddress)
		:I2C(port, deviceaddress)
	{

		m_biascorrectionenable = true;
		m_freerun = false;//FREE RUN OFF
		initialize();
	}

	LidarLite::LidarLite(I2C::Port port)
		:I2C(port, defaultaddress)
	{
		LidarLite(port, defaultaddress);
	}
	LidarLite::~LidarLite()
	{

	}

	void LidarLite::SetFreeRun(bool enable)
	{
		if (enable)
			measurementRepeat(0xff);
		else
			measurementRepeat(0x01);
	}
	void LidarLite::setUpdateDelay(uint8_t delay)
	/*
	 * 0xff = 255 = 7.8hz
	 * 0xc8 = 200 = 10 hz
	 * 0x14 = 20 = 100 hz
	 * 0x01 = 2000hz
	 * 0x00 = ?????
	 *
	 * delay is in units of 0.5ms
	 */
	{
		//set our delay given
		Write(Commands::kMEASURE_DELAY,delay);

		measuredelay = delay;
		uint8_t config = getConfig();

		//set bit 5
		config|= 0b100000;

		setConfig(config);

	}

	void LidarLite::initialize()
	{
		//SetFreeRun(m_freerun);
	}


	void LidarLite::reset()
	//resets the device
	{

		//send reset
		Write(Commands::kACQ_COMMAND, 0x00);


		initialize();
	}


	uint16_t LidarLite::getDistance()
	//returns in cm
	{

		  Write(0x00, 0x00);
		  Wait(.025);
		  Write(0x00, 0x04);
		  Wait(.005);

		  unsigned char djoSendData[1];
		  unsigned char LidarMassData[2];

		  djoSendData[0] = 0x8F;  // Bulk Write Based Read_Only for a two register Read of 0x8F (distance)
		  WriteBulk(djoSendData,1);
		    ReadOnly(1,reinterpret_cast<uint8_t*>(&distance));
		    distance >>= 8;
		    ReadOnly(1,reinterpret_cast<uint8_t*>(&distance));

/*		  ReadOnly(2,LidarMassData);
		  printf("Mass Data 0 %4X \n", LidarMassData[0]);
		  printf("Mass Data 1 %4X \n", LidarMassData[1]);*/
		/*
		//if LIDAR is not taking measurements constantly, take one now
		if (!m_freerun)
			if (m_biascorrectionenable){
				WriteBulk(reinterpret_cast<uint8_t*>(Commands::kACQ_COMMAND), 1);
				WriteBulk(reinterpret_cast<uint8_t*>(0x04), 1);}
			else
				Write(Commands::kACQ_COMMAND, 0x03);

		Write(0x00, 0x00);
	    Wait(.025);
	    Write(0x00, 0x04);
	    Wait(.005);

		int16_t distance = 0;
	    unsigned char djoSendData[1];
	    unsigned char LidarMassData[2];
	      djoSendData[0] = 0x01;  // Bulk Write Based Read_Only for a single register Read of 0x01 (status)
	      WriteBulk(djoSendData,1);
	      ReadOnly(1,LidarMassData);
	      printf("Mass Data 0 %4X \n", LidarMassData[0]);
	      Wait(0.001);

	    djoSendData[0] = 0x8F;  // Bulk Write Based Read_Only for a two register Read of 0x8F (distance)
	    WriteBulk(djoSendData,1);


		/*
	    ReadOnly(2,LidarMassData);
	    printf("Mass Data 0 %4X \n", LidarMassData[0]);
	    printf("Mass Data 1 %4X \n", LidarMassData[1]);*/

/*

		//read low byte
//	    WriteBulk(reinterpret_cast<uint8_t*>((Commands::kLAST_DELAY_LOW)),1);
	    unsigned char *getDistRegister;
	    *getDistRegister = 0x8F;
	    unsigned char distances[2];

	    WriteBulk(getDistRegister,1);
	    ReadOnly(2,distances);
	    printf("Mass Data 0 %4X \n", distances[0]);
	    printf("Mass Data 1 %4X \n", distances[1]);
	    ReadOnly(1,reinterpret_cast<uint8_t*>(&distance));
		distance >>= 8;	//shove low byte to lower 8
	    ReadOnly(1,reinterpret_cast<uint8_t*>(&distance));

		//read high order
//	    WriteBulk(reinterpret_cast<uint8_t*>((Commands::kLAST_DELAY_HIGH)),1);
//	    ReadOnly(1,reinterpret_cast<uint8_t*>(&distance));
	    */
		return 0;
	}

	uint16_t LidarLite::getDistanceOtherEndianness()
	{
		uint16_t distance = getDistance();
		uint16_t temp = distance<<8 | distance >>8;
		return temp;

	}


	double LidarLite::getVelocity()
	/* doesnt work, fix it
	 * returns in cm/s
	 * assumes we are in freerun as this class does not clock itself
	 * if delay is 0 it will crash
	 */
	{
		double distance = 0;
		double velocity = 1;

		//returns signed 2's comp from the last measurement to current
		Read(Commands::kVELOCITY,1,reinterpret_cast<uint8_t*>(&distance));
		//distance is in 2's complement

		if (distance >128)
		{
			//2's complement it
			distance = ~((uint32_t)distance)+1;
			velocity = -1;
		}

		if (measuredelay != 0)
			velocity = (velocity*distance)/(double)measuredelay;
		else
			velocity = (velocity*distance);

		return velocity;
	}

	/***
	 *
	 * Private
	 *
	 */


	void LidarLite::measurementRepeat(uint8_t count)
	{
		Write(Commands::kOUTER_LOOP_COUNT,count);
	}

	uint8_t LidarLite::getStatus()
	{
		uint8_t status = 0;
		WriteBulk(reinterpret_cast<uint8_t*>(Commands::kSTATUS),1);
	    ReadOnly(1,&status);
		return status;
	}

	void LidarLite::setConfig(uint8_t config)
	{
		Write(Commands::kACQ_CONFIG_REG,config);
	}

	uint8_t LidarLite::getConfig()
	{
		uint8_t config = 0;
	    WriteBulk(reinterpret_cast<uint8_t*>(Commands::kACQ_CONFIG_REG),1);
		ReadOnly(1,(&config));
		return config;
	}
	bool LidarLite::isMeasurementValid()
	{
		/**bit 6 set processor error
		 * bit 5 clear health error
		 * bit 4 set secondary return should not make measurement invalid
		 * bit 3 set no return peak detected
		 * bit 2 dont care
		 * bit 1 dont care
		 * bit 0 dont care
		 *
		 *
		 * bit number
		 * 6543210
		 * 01X0XXX mask of a good measurement
		 * 0100000 AND it with 1101000 do clear bits we dont care about
		 * If we get anything other than 010000 our measurement sucks
		 */


		return ((getStatus() & 0x1101000) == 0x0100000);
	}
	bool LidarLite::isBusy()
	{
		return (getStatus() & 0x01) == 0x01;
	}
